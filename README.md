ocamllex
========

Experimental version of ocamllex.

To build, just type ```make``` in an ocaml environment. The generated binary is called ```ocamlmolex```.

Purpose
=======

Lexers generated by standard ocamllex grab the control flow. Desireable interruption points are user actions (e.g. when chaining lexing rules) and refill points.

However the latter is not achievable without hacks: the refill function from lexbuf is called, then flow get backs to lexing code.

How to
======

This version of ```ocamllex``` adds one flag: ```-refill-handler```, whose argument is expected to be the identifier of a function of type ```(Lexing.lexbuf -> 'a -> 'b) -> Lexing.lexbuf -> 'a -> 'b``` reachable from lexer body (for instance the function can be defined in lexer prolog).

The first argument is the continuation, the second the lexing buffer and the last one is some arbitrary parameter to be passed to the continuation. The result, ```'b``` is of the same type as the return value of lexer rules.

You know have full control of the flow, you can for instance embed the generated lexer in an arbitrary monad (like Lwt or Async), etc. 

Writing the handler
===================

The ```refill_handler``` function is expected to prepare the state so that the lexer refill function behave nicely. You will have to use some side channel to make both communicates.

Examples
========

#### Lexing arithmetic in an arbitrary monad

Compile with flag ```-refill-handler refill_handler```.

```ocaml
{
type token = EOL | INT of int | PLUS | MINUS | TIMES | DIV | LPAREN | RPAREN

module Make (M : sig
               type 'a t
               val return: 'a -> 'a t
               val bind: 'a t -> ('a -> 'b t) -> 'b t
               val fail : string -> 'a t

               (* Set up lexbuf *)
               val on_refill : Lexing.lexbuf -> unit t
             end)
= struct
  
let refill_handler k lexbuf arg =
    M.bind (M.on_refill lexbuf) (fun () -> k lexbuf arg)

}
rule token = parse
| [' ' '\t']
    { token lexbuf }
| '\n'
    { M.return EOL }
| ['0'-'9']+ as i
    { M.return (INT (int_of_string i)) }
| '+'
    { M.return PLUS }
| '-'
    { M.return MINUS }
| '*'
  { M.return TIMES }
| '/'
    { M.return DIV }
| '('
    { M.return LPAREN }
| ')'
    { M.return RPAREN }
| eof
    { M.fail "EOF" }
| _
    { M.fail "unexpected character" }
{
end
}
```

#### Using ```Lwt_io```


```ocaml
let current_state = Lwt.new_key ()

module M = struct
  type 'a t = 'a Lwt.t
  let return = Lwt.return
  let bind = Lwt.bind
  let fail s = Lwt.fail (Failure s)

  let on_refill _ =
    match Lwt.get current_state with
    | Some (ic,buf,pos,len) when !pos >= !len ->
      Lwt.bind (Lwt_io.read_into ic buf 0 (String.length buf))
        (fun n ->
           pos := 0; len := n;
           Lwt.return_unit)
    | _ -> Lwt.return_unit
end

module L = Lexer1.Make (M)

type t = (Lwt_io.input_channel * string * int ref * int ref) * Lexing.lexbuf

let from_channel ic : t =
  let buf = String.create 1024 in
  let pos, len = ref 0, ref 0 in
  (ic,buf,pos,len),
  Lexing.from_function (fun buf' n ->
      let available = !len - !pos in
      if available <= 0
      then 0
      else let n' = min available n in
        String.blit buf !pos buf' 0 n';
        pos := !pos + n'; n')

let token (value,lexbuf : t) =
  Lwt.with_value current_state (Some value) (fun () -> L.token lexbuf)
```
